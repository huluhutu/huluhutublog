<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.51" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://mister-hope.github.io/huluhutublog/pages/Interviews/Java/4-JVM.html"><meta property="og:site_name" content="huluhutublog"><meta property="og:title" content="JVM"><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><link rel="icon" href="/huluhutublog/favicon.ico"><link rel="icon" href="/huluhutublog/assets/icon/chrome-mask-512.png" type="image/png" sizes="512x512"><link rel="icon" href="/huluhutublog/assets/icon/chrome-mask-192.png" type="image/png" sizes="192x192"><link rel="icon" href="/huluhutublog/assets/icon/chrome-512.png" type="image/png" sizes="512x512"><link rel="icon" href="/huluhutublog/assets/icon/chrome-192.png" type="image/png" sizes="192x192"><link rel="manifest" href="/huluhutublog/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#46bd87"><link rel="apple-touch-icon" href="/huluhutublog/assets/icon/apple-icon-152.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="msapplication-TileImage" content="/huluhutublog/assets/icon/ms-icon-144.png"><meta name="msapplication-TileColor" content="#ffffff"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><title>JVM | huluhutublog</title><meta name="description" content="That is my Blog!!!">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/huluhutublog/assets/style.dc69c01e.css">
    <link rel="modulepreload" href="/huluhutublog/assets/app.0662e65c.js"><link rel="modulepreload" href="/huluhutublog/assets/4-JVM.html.a25d5605.js"><link rel="modulepreload" href="/huluhutublog/assets/_plugin-vue_export-helper.cdc0426e.js"><link rel="modulepreload" href="/huluhutublog/assets/4-JVM.html.f576159f.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/huluhutublog/" class="brand"><img class="logo" src="/huluhutublog/logo.svg" alt="huluhutublog"><!----><span class="site-name hide-in-pad">huluhutublog</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/huluhutublog/" class="nav-link" aria-label="HULUHUTU"><span class="icon iconfont icon-home"></span>HULUHUTU<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="面试"><span class="title"><span class="icon iconfont icon-note"></span>面试</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/huluhutublog/pages/Interviews/Java/" class="nav-link active" aria-label="Java"><!---->Java<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="计算机基础"><span class="title"><span class="icon iconfont icon-note"></span>计算机基础</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/huluhutublog/pages/FundamentalsOfComputerScience/DataStructuresAndAlgorithms/" class="nav-link" aria-label="数据结构与算法"><!---->数据结构与算法<!----></a></li><li class="dropdown-item"><a href="/huluhutublog/pages/FundamentalsOfComputerScience/ComputerNetwork/" class="nav-link" aria-label="计算机网络"><!---->计算机网络<!----></a></li><li class="dropdown-item"><a href="/huluhutublog/pages/FundamentalsOfComputerScience/OperatingSystem/" class="nav-link" aria-label="操作系统"><!---->操作系统<!----></a></li><li class="dropdown-item"><a href="/huluhutublog/pages/FundamentalsOfComputerScience/PrinciplesOfComputerOrganization/" class="nav-link" aria-label="计算机组成原理"><!---->计算机组成原理<!----></a></li><li class="dropdown-item"><a href="/huluhutublog/pages/FundamentalsOfComputerScience/PrinciplesOfDatabase/" class="nav-link" aria-label="数据库原理"><!---->数据库原理<!----></a></li><li class="dropdown-item"><a href="/huluhutublog/pages/FundamentalsOfComputerScience/DesignPatterns/" class="nav-link" aria-label="设计模式"><!---->设计模式<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="Java"><span class="title"><span class="icon iconfont icon-note"></span>Java</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/huluhutublog/pages/Java/JavaBase/" class="nav-link" aria-label="Java基础"><!---->Java基础<!----></a></li><li class="dropdown-item"><a href="/huluhutublog/pages/Java/JavaIO/" class="nav-link" aria-label="JavaIO"><!---->JavaIO<!----></a></li><li class="dropdown-item"><a href="/huluhutublog/pages/Java/JavaCollection/" class="nav-link" aria-label="Java集合"><!---->Java集合<!----></a></li><li class="dropdown-item"><a href="/huluhutublog/pages/Java/JavaConcurrent/" class="nav-link" aria-label="Java并发编程"><!---->Java并发编程<!----></a></li><li class="dropdown-item"><a href="/huluhutublog/pages/Java/JVM/JVM.html" class="nav-link" aria-label="JVM"><!---->JVM<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="数据库"><span class="title"><span class="icon iconfont icon-note"></span>数据库</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/huluhutublog/pages/DB/MySQL/" class="nav-link" aria-label="MySQL"><!---->MySQL<!----></a></li><li class="dropdown-item"><a href="/huluhutublog/pages/DB/Redis/" class="nav-link" aria-label="Redis"><!---->Redis<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="Spring"><span class="title"><span class="icon iconfont icon-note"></span>Spring</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/huluhutublog/pages/Spring/Spring/" class="nav-link" aria-label="Spring"><!---->Spring<!----></a></li><li class="dropdown-item"><a href="/huluhutublog/pages/Spring/SpringMVC/" class="nav-link" aria-label="SpringMVC"><!---->SpringMVC<!----></a></li><li class="dropdown-item"><a href="/huluhutublog/pages/Spring/SpringBoot/" class="nav-link" aria-label="SpringBoot"><!---->SpringBoot<!----></a></li><li class="dropdown-item"><a href="/huluhutublog/pages/Spring/SpringCloud/" class="nav-link" aria-label="SpringCloud"><!---->SpringCloud<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="消息队列"><span class="title"><span class="icon iconfont icon-note"></span>消息队列</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/huluhutublog/pages/MQ/RabbitMQ/" class="nav-link" aria-label="RabbitMQ"><!---->RabbitMQ<!----></a></li><li class="dropdown-item"><a href="/huluhutublog/pages/MQ/RocketMQ/" class="nav-link" aria-label="RocketMQ"><!---->RocketMQ<!----></a></li><li class="dropdown-item"><a href="/huluhutublog/pages/MQ/Kafka/" class="nav-link" aria-label="Kafka"><!---->Kafka<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="分布式"><span class="title"><span class="icon iconfont icon-note"></span>分布式</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/huluhutublog/pages/Distributed/Artritecture/" class="nav-link" aria-label="架构"><!---->架构<!----></a></li><li class="dropdown-item"><a href="/huluhutublog/pages/Distributed/Distributed/" class="nav-link" aria-label="分布式理论"><!---->分布式理论<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="开发工具"><span class="title"><span class="icon iconfont icon-note"></span>开发工具</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/huluhutublog/pages/DevelopmentTools/Git/" class="nav-link" aria-label="Git"><!---->Git<!----></a></li><li class="dropdown-item"><a href="/huluhutublog/pages/DevelopmentTools/Linux/" class="nav-link" aria-label="Linux"><!---->Linux<!----></a></li><li class="dropdown-item"><a href="/huluhutublog/pages/DevelopmentTools/Docker/" class="nav-link" aria-label="Docker"><!---->Docker<!----></a></li><li class="dropdown-item"><a href="/huluhutublog/pages/DevelopmentTools/Maven/" class="nav-link" aria-label="Maven"><!---->Maven<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="项目"><span class="title"><span class="icon iconfont icon-note"></span>项目</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/huluhutublog/pages/Project/SwiftHome/" class="nav-link" aria-label="快捷到家"><!---->快捷到家<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="部署"><span class="title"><span class="icon iconfont icon-note"></span>部署</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/huluhutublog/pages/Deploy/Blog/" class="nav-link" aria-label="vuepress"><!---->vuepress<!----></a></li></ul></button></div></div></nav><!----></div><div class="navbar-right"><!----><!----><div class="nav-item"><a class="repo-link" href="https://github.com/vuepress-theme-hope/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><!----><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><section class="sidebar-group"><button class="sidebar-heading clickable active"><span class="icon iconfont icon-note"></span><span class="title">Java面试</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/huluhutublog/pages/Interviews/Java/" class="nav-link sidebar-link sidebar-page" aria-label="Java面试指南"><!---->Java面试指南<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/huluhutublog/pages/Interviews/Java/1-Java%E5%9F%BA%E7%A1%80.html" class="nav-link sidebar-link sidebar-page" aria-label="Java基础"><!---->Java基础<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/huluhutublog/pages/Interviews/Java/2-Java%E9%9B%86%E5%90%88.html" class="nav-link sidebar-link sidebar-page" aria-label="Java集合"><!---->Java集合<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/huluhutublog/pages/Interviews/Java/3-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html" class="nav-link sidebar-link sidebar-page" aria-label="并发编程"><!---->并发编程<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="JVM"><!---->JVM<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#说一下jvm的内存区域以及在jdk1-6、1-7、1-8版本的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="说一下JVM的内存区域以及在JDK1.6、1.7、1.8版本的区别"><!---->说一下JVM的内存区域以及在JDK1.6、1.7、1.8版本的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#说说类加载过程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="说说类加载过程"><!---->说说类加载过程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#聊一下创建对象的过程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="聊一下创建对象的过程"><!---->聊一下创建对象的过程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#什么是内存溢出和内存泄漏" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="什么是内存溢出和内存泄漏"><!---->什么是内存溢出和内存泄漏<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#堆的内存分区" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="堆的内存分区"><!---->堆的内存分区<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#jvm是如何判断对象是否存活-被引用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="JVM是如何判断对象是否存活（被引用）"><!---->JVM是如何判断对象是否存活（被引用）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#垃圾回收算法有哪些" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="垃圾回收算法有哪些"><!---->垃圾回收算法有哪些<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#标记清除算法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="标记清除算法："><!---->标记清除算法：<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#标记复制算法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="标记复制算法"><!---->标记复制算法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#标记整理算法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="标记整理算法"><!---->标记整理算法<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#gc方式有哪些-什么时候触发" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="GC方式有哪些，什么时候触发"><!---->GC方式有哪些，什么时候触发<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#minorgc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="MinorGC"><!---->MinorGC<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#majorgc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="MajorGC"><!---->MajorGC<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#fullgc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="FullGC"><!---->FullGC<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#mixgc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="MixGC"><!---->MixGC<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#说一下stw-stop-the-world" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="说一下STW（Stop The World）"><!---->说一下STW（Stop The World）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#说说你了解的垃圾收集器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="说说你了解的垃圾收集器"><!---->说说你了解的垃圾收集器<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#新生代" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="新生代"><!---->新生代<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#老年代" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="老年代"><!---->老年代<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#g1收集器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="G1收集器"><!---->G1收集器<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#垃圾收集器如何选择" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="垃圾收集器如何选择"><!---->垃圾收集器如何选择<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#你做过哪些调优" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="你做过哪些调优"><!---->你做过哪些调优<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/huluhutublog/pages/Interviews/Java/5-JavaIO.html" class="nav-link sidebar-link sidebar-page" aria-label="JavaIO"><!---->JavaIO<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->JVM</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://mrhope.site" target="_blank" rel="noopener noreferrer">huluhutu</a></span><span property="author" content="huluhutu"></span></span><!----><!----><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 11 分钟</span><meta property="timeRequired" content="PT11M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#说一下jvm的内存区域以及在jdk1-6、1-7、1-8版本的区别" class="router-link-active router-link-exact-active toc-link level2">说一下JVM的内存区域以及在JDK1.6、1.7、1.8版本的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#说说类加载过程" class="router-link-active router-link-exact-active toc-link level2">说说类加载过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#聊一下创建对象的过程" class="router-link-active router-link-exact-active toc-link level2">聊一下创建对象的过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#什么是内存溢出和内存泄漏" class="router-link-active router-link-exact-active toc-link level2">什么是内存溢出和内存泄漏</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#堆的内存分区" class="router-link-active router-link-exact-active toc-link level2">堆的内存分区</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#jvm是如何判断对象是否存活-被引用" class="router-link-active router-link-exact-active toc-link level2">JVM是如何判断对象是否存活（被引用）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#垃圾回收算法有哪些" class="router-link-active router-link-exact-active toc-link level2">垃圾回收算法有哪些</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#标记清除算法" class="router-link-active router-link-exact-active toc-link level3">标记清除算法：</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#标记复制算法" class="router-link-active router-link-exact-active toc-link level3">标记复制算法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#标记整理算法" class="router-link-active router-link-exact-active toc-link level3">标记整理算法</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#gc方式有哪些-什么时候触发" class="router-link-active router-link-exact-active toc-link level2">GC方式有哪些，什么时候触发</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#minorgc" class="router-link-active router-link-exact-active toc-link level3">MinorGC</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#majorgc" class="router-link-active router-link-exact-active toc-link level3">MajorGC</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#fullgc" class="router-link-active router-link-exact-active toc-link level3">FullGC</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#mixgc" class="router-link-active router-link-exact-active toc-link level3">MixGC</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#说一下stw-stop-the-world" class="router-link-active router-link-exact-active toc-link level2">说一下STW（Stop The World）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#说说你了解的垃圾收集器" class="router-link-active router-link-exact-active toc-link level2">说说你了解的垃圾收集器</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#新生代" class="router-link-active router-link-exact-active toc-link level3">新生代</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#老年代" class="router-link-active router-link-exact-active toc-link level3">老年代</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#g1收集器" class="router-link-active router-link-exact-active toc-link level3">G1收集器</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#垃圾收集器如何选择" class="router-link-active router-link-exact-active toc-link level2">垃圾收集器如何选择</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/huluhutublog/pages/Interviews/Java/4-JVM.html#你做过哪些调优" class="router-link-active router-link-exact-active toc-link level2">你做过哪些调优</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="jvm" tabindex="-1"><a class="header-anchor" href="#jvm" aria-hidden="true">#</a> JVM</h1><h2 id="说一下jvm的内存区域以及在jdk1-6、1-7、1-8版本的区别" tabindex="-1"><a class="header-anchor" href="#说一下jvm的内存区域以及在jdk1-6、1-7、1-8版本的区别" aria-hidden="true">#</a> 说一下JVM的内存区域以及在JDK1.6、1.7、1.8版本的区别</h2><p><img src="https://raw.githubusercontent.com/huluhutu/blogimg/main/img/image-20221016083052568.png" alt="image-20221016083052568" loading="lazy"></p><p><strong>JDK1.8</strong></p><p>运行时数据区分为</p><ul><li>线程共享 <ul><li>元空间：存放类信息，运行时常量池，存放在直接内存中</li><li>堆：存放字符串常量池以及绝大部分对象</li></ul></li><li>线程私有 <ul><li>虚拟机栈：栈中是一个个方法的递归调用，每个方法里有局部变量表，操作数栈，动态链接（符号引用转为直接引用），方法出口等信息，同时有可能有些对象就分配在这里</li><li>本地方法栈：与虚拟机栈类似，但是里面放的是native method</li><li>程序计数器：记录下一条运行指令；作用就是可以让中断的程序恢复到运行的那个进度</li></ul></li></ul><p><strong>JDK1.7</strong></p><p>与JDK1.8不同的是元空间叫作方法区，且存放在运行时数据区内</p><p><strong>JDK1.6</strong></p><p>与JDK1.7不同的是，字符串常量池是放在方法区上</p><h2 id="说说类加载过程" tabindex="-1"><a class="header-anchor" href="#说说类加载过程" aria-hidden="true">#</a> 说说类加载过程</h2><p><img src="https://raw.githubusercontent.com/huluhutu/blogimg/main/img/image-20221016084319286.png" alt="image-20221016084319286" loading="lazy"></p><ul><li>磁盘中存有Java文件，读取Java文件，进行编译（涉及到编译原理）成class文件</li><li>对这个class文件加载就用了双亲委派机制 <ul><li>首先Application想加载，但是得先交给父亲Extension去加载，再交由其父亲BootStrap加载（<strong>这一阶段是验证该类是否已经加载过了</strong>）</li><li>BootStrap认为这个类不适合自己加载，就交由子类，子类交由子类。这么做的好处就是为了安全性（<strong>这一阶段是看看自己的类加载器是否可以加载该类</strong>）</li><li>好处：<strong>可以保正加载的类只有一个，同时也是保证了API的安全性，防止被篡改，覆盖等</strong></li></ul></li><li>确定加载类后类加载子系统会有个link的过程，就是验证（验证是否规范）、准备（初始化变量）、解析（符号引用变为直接引用），然后再初始化（生成Class对象存入堆中），就可以使用了</li></ul><h2 id="聊一下创建对象的过程" tabindex="-1"><a class="header-anchor" href="#聊一下创建对象的过程" aria-hidden="true">#</a> 聊一下创建对象的过程</h2><p><img src="https://raw.githubusercontent.com/huluhutu/blogimg/main/img/image-20221016091357777.png" alt="image-20221016091357777" loading="lazy"></p><ul><li>创建对象时会先查看该类是否加载了 <ul><li>通过new指令参数查看元空间中是否有对应的符号引用</li><li>如果符号应用未初始化则加载该类</li></ul></li><li>内存分配阶段：在堆或者栈上给对象分配内存 <ul><li>首先会检测该对象时候逃逸，如果未逃逸，则在栈上分配，如果可逃逸，则在堆上分配</li><li>逃逸分析：可能被非本方法的东西所引用，则为逃逸成功</li><li>栈上分配成功后需要标量替换和同步消除（消除同步机制）</li><li>一般情况下堆分配： <ul><li>指针碰撞：堆的划分是规整的，指针处于空闲内存和非空闲内存之间，存储对象后指针位移对应的空间大小的位置</li><li>空闲列表：记录哪些内存空间可用</li></ul></li><li>并发环境下： <ul><li>CAS：多个线程抢占同一堆空间的时候，可以通过自旋来解决，但要是迟迟获取不到，那堆性能消耗是很大的</li><li>TLAB：每个线程都在堆中有自己的一定空间，并发下，存储在自己的堆空间上就不用考虑线程安全问题了</li></ul></li></ul></li><li>初始化零值：给各个变量赋值初始值</li><li>设置对象头： <ul><li><img src="https://raw.githubusercontent.com/huluhutu/blogimg/main/img/image-20221016103524327.png" alt="image-20221016103524327" loading="lazy"></li></ul></li><li>执行&lt;init&gt;：先是执行父类的静态变量和代码块，再执行子类的静态变量和代码块，接着执行父类的代码块和构造方法，再执行子类的代码块和构造方法</li></ul><h2 id="什么是内存溢出和内存泄漏" tabindex="-1"><a class="header-anchor" href="#什么是内存溢出和内存泄漏" aria-hidden="true">#</a> 什么是内存溢出和内存泄漏</h2><p><strong>内存溢出</strong>：就是可用内存不足以被申请使用了</p><p><strong>内存泄漏</strong>：就是有东西占着内存，但它又没有什么用，这就是内存泄漏</p><p><strong>内存泄漏的原因</strong>:</p><ul><li>无用的静态集合类</li><li>单例模式</li><li>连接IO，不用又不释放</li><li>变量的作用域过大，咋成没必要的浪费</li><li>Hash值的改变，在HashMap中，某个keyHash值改变了，导致查找的时候找不到这个Entry，这就造成内存泄漏了，这也是为什么String要定义为final的原因之一</li><li>ThreadLocal使用不当，众所周知，其key是偌引用，如果没有remove会被GC回收，但是value却不会，导致key为null，这样的话就是造成了内存泄漏了</li></ul><h2 id="堆的内存分区" tabindex="-1"><a class="header-anchor" href="#堆的内存分区" aria-hidden="true">#</a> 堆的内存分区</h2><p><img src="https://raw.githubusercontent.com/huluhutu/blogimg/main/img/image-20221016135742846.png" alt="image-20221016135742846" loading="lazy"></p><p>众所周知，堆划分为新生代和老年代，期中新生代存放生命周期短的对象，老年代则相反，为什么要这么划分呢，当然是为了GC而设计的啦，说一下默认的划分，新生代（1/3），老年代（2/3），并且新生代中分为Eden（8/10）和SurvivorFrom（1/10），SurvivorTo（1/10），这两个survivor只存在一个为空，里面的对象每移动一次，年龄加一，加到一定的年龄（默认15）就送进老年代了。当然，大对象会直接送进老年代，因为新生代容量不多，但是小对象多，这样做也是为了防止频繁GC</p><h2 id="jvm是如何判断对象是否存活-被引用" tabindex="-1"><a class="header-anchor" href="#jvm是如何判断对象是否存活-被引用" aria-hidden="true">#</a> JVM是如何判断对象是否存活（被引用）</h2><p>判断对象是否存活，主要是看对象是否被引用，有两种方式</p><ul><li><p><strong>引用计数法</strong>：对象中添加一个引用计数器，每有引用它的时候，计数器会加1，当不引用了，计数器会减1</p><ul><li>优点：实现简单，判定效率高，回收延迟非常低</li><li>缺点：需要单独的字段存储计数器，增加了空间的损耗，每次赋值都要操作计数器，降低了性能，最严重的问题时无法解决循环依赖，所以垃圾回收器没有使用这种算法</li></ul></li><li><p><strong>可达性分析</strong>：将一些GC Root作为初始对象存储的集合GC Root Set，然后遍历该集合，顺着这些对象触发，查找能够被引用的对象并加入到集合当中，这样集合里全是存活的对象，这个过程称之为mark,伴随着STW</p><ul><li>优点：解决循环依赖的问题</li><li>缺点：每次分析消耗比较大的性能</li></ul></li><li><p><strong>OopMap</strong>：为了解决可达性分析的缺点，诞生了OopMap，能够极大提高效率，记录了执行到该方法的某条指令的时候，栈上和寄存器里哪些位置是引用</p><p>在StackOverFlow上找到相关解答<a href="https://stackoverflow.com/questions/26029764/what-does-oop-maps-means-in-hotspot-vm-exactly/26049445#26049445" target="_blank" rel="noopener noreferrer">java - What does Oop Maps means in Hotspot VM exactly - Stack Overflow<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>OopMap是JIT编译方法时一起生成的，一遍JVM能够快速找到对应的引用。而生成OopMap的是在程序达到safe point的时候才生成的</p></li><li><p><strong>safe point</strong>：</p><ul><li>循环的末尾</li><li>方法临返回前 / 调用方法的call指令后</li><li>可能抛异常的位置</li></ul></li><li><p><strong>记忆集</strong>：在可达性分析的时候，可能存在跨代问题，这时候如果又去扫描老年代，就会导致效率非常低下，相当于FullGC了，为此，引入了记录集，记录了收集区到非收集区的集合</p></li><li><p><strong>卡表</strong>：HptSpot就是使用了卡表来实现记忆集的</p></li></ul><h2 id="垃圾回收算法有哪些" tabindex="-1"><a class="header-anchor" href="#垃圾回收算法有哪些" aria-hidden="true">#</a> 垃圾回收算法有哪些</h2><h3 id="标记清除算法" tabindex="-1"><a class="header-anchor" href="#标记清除算法" aria-hidden="true">#</a> <strong>标记清除算法</strong>：</h3><ul><li>标记 : 标记出所有需要回收的对象</li><li>清除 ：回收所有被标记的对象</li><li>缺点：产生大量的内存碎片</li></ul><h3 id="标记复制算法" tabindex="-1"><a class="header-anchor" href="#标记复制算法" aria-hidden="true">#</a> <strong>标记复制算法</strong></h3><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一 块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把 已使用过的内存空间一次清理掉。<strong>一般在新生代中使用。</strong></p><ul><li><p>优点：执行效率高</p></li><li><p>缺点：空间浪费</p></li></ul><h3 id="标记整理算法" tabindex="-1"><a class="header-anchor" href="#标记整理算法" aria-hidden="true">#</a> <strong>标记整理算法</strong></h3><p>其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进 行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存</p><p><strong>标记-整理算法主要用于老年代</strong>，移动存活对象是个极为负重的操作，而且这种操作 需要Stop The World才能进行，只是从整体的吞吐量来考量，老年代使用标记-整理算 法更加合适。</p><h2 id="gc方式有哪些-什么时候触发" tabindex="-1"><a class="header-anchor" href="#gc方式有哪些-什么时候触发" aria-hidden="true">#</a> GC方式有哪些，什么时候触发</h2><h3 id="minorgc" tabindex="-1"><a class="header-anchor" href="#minorgc" aria-hidden="true">#</a> <strong>MinorGC</strong></h3><ul><li>新生代垃圾回收</li><li>当新生代无法为新生对象分配内存空间的时候（Survivor区满后是不会触发），会触发Minor GC，因为新生代中大多数对象的生命周期都很短，所以发生Minor GC的频率很高，虽然它会触发STW，但是它的回收速度很快</li></ul><h3 id="majorgc" tabindex="-1"><a class="header-anchor" href="#majorgc" aria-hidden="true">#</a> <strong>MajorGC</strong></h3><ul><li>老年代垃圾回收</li></ul><h3 id="fullgc" tabindex="-1"><a class="header-anchor" href="#fullgc" aria-hidden="true">#</a> <strong>FullGC</strong></h3><ul><li>整个Java堆和方法区</li><li><strong>MinorGC之前检查老年代</strong> ：在要进行 MajorGC 的时候，发现老年代可用的连续内存空间 &lt; 新生代历次MajorGC后升入老年代的对象总和的平均大小 ，说明本次 MinorGC后可能升入老年代的对象大小，可能超过了老年代当前可用内存空间, 那就会触发 Full GC。</li><li><strong>MinorGC之后老年代空间不足</strong> ：执行MajorGC之后有一批对象需要放入老年 代，此时老年代就是没有足够的内存空间存放这些对象了，此时必须立即触发一 次Full GC</li><li><strong>老年代空间不足 ，老年代内存使用率过高，达到一定比例</strong>，也会触发Full GC。</li><li><strong>空间分配担保失败</strong> （ Promotion Failure），新生代的 To 区放不下从 Eden 和 From 拷贝过来对象，或者新生代对象 GC 年龄到达阈值需要晋升这两种情况， 老年代如果放不下的话都会触发 Full GC。</li><li><strong>方法区内存空间不足</strong> ：如果方法区由永久代实现，永久代空间不足 Full GC。</li><li><strong>System.gc()等命令触发</strong> ：System.gc()、jmap -dump 等命令会触发 full gc。</li></ul><h3 id="mixgc" tabindex="-1"><a class="header-anchor" href="#mixgc" aria-hidden="true">#</a> <strong>MixGC</strong></h3><ul><li>目前只有G1收集器采用这种方式，同时回收年轻代与老年代</li></ul><h2 id="说一下stw-stop-the-world" tabindex="-1"><a class="header-anchor" href="#说一下stw-stop-the-world" aria-hidden="true">#</a> 说一下STW（Stop The World）</h2><p>STW就是暂停所有的用户线程，此时，只有可达性分析或者垃圾回收线程可运行。若是在实际开发中，STW的时间比较长，会给用户带来很不好的体验，互联网中就有3秒定律，如果相应时间超过3秒，用户就容易不耐烦了。</p><p>STW的时机，所有的用户线程都会进入safe point才会触发，而让所有线程进入safe point的方式有多种方式，这里可以自己思考一下，如何让所有线程停止</p><p>达到某一时刻，设置一个标志位，让所有线程去轮询这个标志位，一旦设置为true，就代表要进入STW，让所有线程一到达安全点的时候，就停止，但是吧，有些线程处于阻塞或者等待状态的时候，就不能感知到STW了，若是此时进入了STW状态，某线程退出等待状态的话，就会有可能发生一些不可预知的错误，比如说，需要某个引用，但是它却没有了。如果某一线程到达安全点的时间太长了，也会导致相应特别慢，或者说无法产生新的对象。</p><h2 id="说说你了解的垃圾收集器" tabindex="-1"><a class="header-anchor" href="#说说你了解的垃圾收集器" aria-hidden="true">#</a> 说说你了解的垃圾收集器</h2><p><img src="https://raw.githubusercontent.com/huluhutu/blogimg/main/img/image-20221016162033467.png" alt="image-20221016162033467" loading="lazy"></p><h3 id="新生代" tabindex="-1"><a class="header-anchor" href="#新生代" aria-hidden="true">#</a> 新生代</h3><h4 id="serial" tabindex="-1"><a class="header-anchor" href="#serial" aria-hidden="true">#</a> Serial</h4><p>使用复制算法，是一个单线程的收集器，收集的时候必须STW，如果说STW的时间不长的话，还是可以接受的</p><h4 id="parnew" tabindex="-1"><a class="header-anchor" href="#parnew" aria-hidden="true">#</a> ParNew</h4><p>使用复制算法，是Serial的多线程版本，也是需要STW</p><h4 id="parallerscavenge" tabindex="-1"><a class="header-anchor" href="#parallerscavenge" aria-hidden="true">#</a> parallerScavenge</h4><p>采用复制算法，多线程并发收集器，最大的特点是能够自动调整GC策略，JVM会根据系统运行状态和性能监控，动态设置参数，以提供最佳的STW Time</p><h3 id="老年代" tabindex="-1"><a class="header-anchor" href="#老年代" aria-hidden="true">#</a> 老年代</h3><h4 id="serialold" tabindex="-1"><a class="header-anchor" href="#serialold" aria-hidden="true">#</a> SerialOld</h4><p>采用标记整理算法，Serial的老年代版本</p><h4 id="parallerold" tabindex="-1"><a class="header-anchor" href="#parallerold" aria-hidden="true">#</a> ParallerOld</h4><p>采用标记整理算法，ParallerScavenge的老年代版本</p><h4 id="cms" tabindex="-1"><a class="header-anchor" href="#cms" aria-hidden="true">#</a> CMS</h4><p>采用标记清除算法，它设计的目的就是为了尽可能缩短每次STW的时间，但是一次GC的总的STW时间是要比其他收集器要长的，收集结束后会产生大量的内存碎片</p><p><strong>回收过程</strong></p><h3 id="g1收集器" tabindex="-1"><a class="header-anchor" href="#g1收集器" aria-hidden="true">#</a> G1收集器</h3><p>采用标记整理算法，可以精确控制停顿的时间，G1将堆划分为多个Region，维护了一个优先列表，每次回收根据STW的时间采用最优策略</p><h2 id="垃圾收集器如何选择" tabindex="-1"><a class="header-anchor" href="#垃圾收集器如何选择" aria-hidden="true">#</a> 垃圾收集器如何选择</h2><h2 id="你做过哪些调优" tabindex="-1"><a class="header-anchor" href="#你做过哪些调优" aria-hidden="true">#</a> 你做过哪些调优</h2></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/vuepress-theme-hope/vuepress-theme-hope/edit/main/docs/pages/Interviews/Java/4-JVM.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><!----><!----></footer><nav class="page-nav"><a href="/huluhutublog/pages/Interviews/Java/3-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html" class="nav-link prev" aria-label="并发编程"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->并发编程</div></a><a href="/huluhutublog/pages/Interviews/Java/5-JavaIO.html" class="nav-link next" aria-label="JavaIO"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">JavaIO<!----></div></a></nav><div class="giscus-wrapper input-top" style="display:block;"><div style="text-align:center">Loading...</div></div><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">默认页脚</div><div class="copyright">Copyright © 2022 huluhutu</div></footer><!--]--></div><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/huluhutublog/assets/app.0662e65c.js" defer></script>
  </body>
</html>
